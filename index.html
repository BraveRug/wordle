<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Letter Frequency</title>
  <link href="https://fonts.googleapis.com/css2?family=Didact+Gothic&display=swap" rel="stylesheet">
  <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
  <script src="dictionary.js"></script>
  <style>
    /* Core Variables */
    :root {
      --bg: #ffffff;
      --text: #111;
      --accent: #0077cc;
      --input-bg: #f0f0f0;
      --card-bg: #ffffff;
      --settings-icon-bg: rgba(128, 128, 128, 0.2);
    }

    /* Theme Definitions */
    body.light {
      --bg: #ffffff;
      --text: #111;
      --accent: #0077cc;
      --input-bg: #f0f0f0;
      --card-bg: #ffffff;
      --settings-icon-bg: rgba(128, 128, 128, 0.2);
    }
    body.solarized { /* Polarized */
      --bg: #fdf6e3;
      --text: #657b83;
      --accent: #268bd2;
      --input-bg: #f5f2dd;
      --card-bg: #eee8d5;
      --settings-icon-bg: rgba(101, 123, 131, 0.2); /* Adjusted for theme */
    }
    body.cherry { /* Red Light */
      --bg: #ffe6e6;
      --text: #5a0000;
      --accent: #cc0000;
      --input-bg: #ffd6d6;
      --card-bg: #ffcccc;
    }
    body.peach { /* Orange Light */
      --bg: #fff1e6;
      --text: #6b4226;
      --accent: #ff7f50;
      --input-bg: #ffedd5;
      --card-bg: #ffe5d9;
    }
    body.sunshine { /* Yellow Light */
      --bg: #fffde7;
      --text: #6b4a2b;
      --accent: #fbc02d;
      --input-bg: #fff59d;
      --card-bg: #fffbc0;
    }
    body.forest { /* Green Light */
      --bg: #e7f5e9;
      --text: #2d4739;
      --accent: #2e8b57;
      --input-bg: #c8e6c9;
      --card-bg: #d0f0d8;
    }
    body.ocean { /* Cyan Light */
      --bg: #e0f7fa;
      --text: #004d40;
      --accent: #00acc1;
      --input-bg: #b2ebf2;
      --card-bg: #e0f2f1;
    }
    body.azure { /* Cornflower Blue Light */
      --bg: #f0f8ff;
      --text: #003366;
      --accent: #3399ff;
      --input-bg: #e0f0ff;
      --card-bg: #d6ecff;
    }
    body.bluelight { /* Normal Blue Light */
      --bg: #e6f2ff;
      --text: #003366;
      --accent: #007bff;
      --input-bg: #cce5ff;
      --card-bg: #e0f4ff;
    }
    body.violetlight { /* Bluish Purple Light */
      --bg: #f3e5f5;
      --text: #311b92;
      --accent: #7e57c2;
      --input-bg: #d1c4e9;
      --card-bg: #e0d7f7;
    }
    body.plum { /* Normal Purple Light - Enhanced */
      --bg: #f3e5f5; /* Softer purple, was #f9f4fc */
      --text: #311b92; /* Deeper purple text for better contrast, was #4b0082 */
      --accent: #7e57c2; /* Vibrant purple accent, was #9c27b0 */
      --input-bg: #e9d2fd; /* Light purple input, was #f0e5f9 */
      --card-bg: #f0e0ff; /* Slightly more saturated card, was #ede7f6 */
    }
    body.reddishpurple { /* Reddish Purple Light */
      --bg: #fdf1f5;
      --text: #880e4f;
      --accent: #ad1457;
      --input-bg: #f3dce6;
      --card-bg: #f8e1ec;
    }
    body.blush { /* Light Pink Light */
      --bg: #ffeef8;
      --text: #880e4f;
      --accent: #f06292;
      --input-bg: #ffe0eb;
      --card-bg: #ffd6e9;
    }
    body.rose { /* Hot Pink Light - Enhanced */
      --bg: #fff0f5;    /* Retain light pink background */
      --text: #730039;   /* Darker, more saturated pink/maroon for text, was #880e4f */
      --accent: #c2185b; /* Slightly adjusted hot pink accent, was #d81b60 */
      --input-bg: #ffdde9; /* Softer input background, was #ffe4ec */
      --card-bg: #ffe8f0; /* Lighter card background, was #f8bbd0 */
    }
    body.brownlight { /* Brown Light */
      --bg: #f5f0e6;
      --text: #4e342e;
      --accent: #8d6e63;
      --input-bg: #efebe9;
      --card-bg: #e0d7d1;
    }
    body.greyscale { /* Grey Light */
      --bg: #f5f5f5;
      --text: #333;
      --accent: #999;
      --input-bg: #ddd;
      --card-bg: #eee;
    }

    /* Ash Themes */
    /* Ashwood and Slateash removed */
    body.ash { /* Dark Slate Blue/Grey with Grey Accent */
      --bg: #333a45; 
      --text: #F1FAEE; 
      --accent: #8892A0;  /* Changed to neutral grey */
      --input-bg: #2a3038;
      --card-bg: #3b424d;
      --settings-icon-bg: rgba(136, 146, 160, 0.25); /* Using new grey accent */
    }

    /* Dark Themes */
    body.dark {
      --bg: #121212;
      --text: #e0e0e0;
      --accent: #4a90e2;
      --input-bg: #2a2a2a;
      --card-bg: #1e1e1e;
    }
    body.midnight {
      --bg: #0d1b2a;
      --text: #e0e1dd;
      --accent: #415a77;
      --input-bg: #1b263b;
      --card-bg: #1e2a3a;
    }
    body.reddark { /* Red Dark - Enhanced */
      --bg: #281818; /* Slightly darker red-tinged background, was #2b1a1a */
      --text: #ffdad4; /* Softer red text for readability, was #ffcfcf */
      --accent: #ff6659; /* More vibrant red accent, was #ff4d4d */
      --input-bg: #3f201d; /* Darker input, was #3a1f1f */
      --card-bg: #381c18; /* Darker card, was #342020 */
    }

    body.orangedark { /* Orange Dark - Enhanced */
      --bg: #2c1f13; /* Slightly darker orange-tinged background, was #2e2115 */
      --text: #ffe8d1; /* Lighter, softer orange text, was #ffddb3 */
      --accent: #ff8c3d; /* More vibrant orange accent, was #ff944d */
      --input-bg: #422c1a; /* Darker input, was #3c2a1a */
      --card-bg: #3b2717; /* Darker card, was #352518 */
    }

    body.yellowdark { /* Yellow Dark - Enhanced */
      --bg: #2e2a18; /* Darker yellow-tinged background, was #2f2b1a */
      --text: #fffacc; /* Brighter yellow text, was #fff7cc */
      --accent: #ffd644; /* Richer yellow accent, was #ffde59 */
      --input-bg: #453f1e; /* Darker input, was #3d391f */
      --card-bg: #3e381b; /* Darker card, was #35321a */
    }

    body.greendark {
      --bg: #1a2b1a;
      --text: #c2ffc2;
      --accent: #66bb6a;
      --input-bg: #243524;
      --card-bg: #1f2e1f;
    }

    body.cyandark { /* Cyan Dark - Enhanced */
      --bg: #0f2929; /* Darker cyan background, was #102b2b */
      --text: #c1ffff; /* Brighter cyan text, was #b2ffff */
      --accent: #21c0d4; /* More vibrant cyan accent, was #26c6da */
      --input-bg: #174040; /* Darker input, was #1a3c3c */
      --card-bg: #143a3a; /* Darker card, was #173636 */
    }

    body.azuredark {
      --bg: #162339;
      --text: #ccddff;
      --accent: #3399ff;
      --input-bg: #21304a;
      --card-bg: #1d2a40;
    }

    body.deepsea {
      --bg: #152233;
      --text: #a8dfff;
      --accent: #33cccc;
      --input-bg: #1e2e44;
      --card-bg: #1a283c;
    }

    body.violetnight {
      --bg: #1e1b2e;
      --text: #b9b4d9;
      --accent: #a18aff;
      --input-bg: #2a263f;
      --card-bg: #26233a;
    }

    body.purpledark {
      --bg: #1f152e;
      --text: #d2c8ff;
      --accent: #9575cd;
      --input-bg: #2d1f44;
      --card-bg: #281d3c;
    }

    body.merlot { /* Reddish Purple Dark - Enhanced */
      --bg: #25121e;    /* Darker, more purple background */
      --text: #ffd9f0;    /* Lighter pink text for contrast */
      --accent: #d81b60;  /* More vibrant magenta accent */
      --input-bg: #3d182f; /* Darker input background */
      --card-bg: #331428;   /* Darker card background */
    }
    body.lightpinkdark { /* Light Pink Dark - Enhanced */
      --bg: #281822;    /* Darker pink-tinged background */
      --text: #ffe8f3;    /* Softer, lighter pink text */
      --accent: #ef7ba7;  /* Adjusted light pink accent for better visibility */
      --input-bg: #402030; /* Darker input background */
      --card-bg: #381c2a;   /* Darker card background */
    }

    body.hotpinkdark { /* Hot Pink Dark - Enhanced */
      --bg: #2d1222;    /* Darker hot pink background */
      --text: #ffd6e8;    /* Lighter, more vibrant pink text */
      --accent: #e0306e;  /* Adjusted hot pink accent for clarity */
      --input-bg: #451830; /* Darker input background */
      --card-bg: #3b1529;   /* Darker card background */
    }

    body.browndark {
      --bg: #261b15;
      --text: #e0d6d2;
      --accent: #a1887f;
      --input-bg: #3a2b26;
      --card-bg: #2f221d;
    }

    body.charcoal { /* Grey Dark */
      --bg: #1c1c1c;
      --text: #f5f5f5;
      --accent: #888;
      --input-bg: #2b2b2b;
      --card-bg: #252525;
    }
    body.infernoslate { /* Dark Slate BG, Red Container, Teal Accent */
      --bg: #333a45;
      --text: #F1FAEE;
      --accent: #A8DADC; /* Light Teal/Cyan */
      --card-bg: #e63946; /* Red for the main div.container */
      --input-bg: #333a45; /* Matching page BG for input/result boxes */
      --settings-icon-bg: rgba(168, 218, 220, 0.25); /* Teal accent with transparency */
    }


    /* Onyx Themes */
    body.obsidian { /* Very dark grey, near black with vibrant blue accent */
      --bg: #0b0c0e; 
      --text: #e8e9eb; 
      --accent: #00aaff; 
      --input-bg: #181a1d;
      --card-bg: #121315;
      --settings-icon-bg: rgba(20, 22, 25, 0.3);
    }
    body.blackopal { /* True black with deep amethyst accent */
      --bg: #050505; 
      --text: #f0f0f0; 
      --accent: #7e38b0; 
      --input-bg: #161616;
      --card-bg: #0f0f0f;
      --settings-icon-bg: rgba(15, 15, 15, 0.4);
    }

    /* Global Styles */
    * { box-sizing: border-box; font-family: 'Didact Gothic', sans-serif; transition: background-color 0.3s, color 0.3s, border-color 0.3s; }
    body { margin:0; background:var(--bg); color:var(--text); display:flex; flex-direction:column; align-items:center; padding:20px; min-height:100vh; }
    
    .app-header { display: flex; justify-content: center; align-items: center; width:100%; max-width:500px; position: relative; margin-bottom: 20px; }
    .app-header h2 { margin:0; text-align:center; flex-grow: 1; } /* Title takes available space */

    #searchBtn {
        position: absolute;
        left: 0;
        font-size: 1.2em;
    }

    .header-btn {
        background: var(--settings-icon-bg);
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        color: var(--text);
        border-radius: 50%;
        padding: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        transition: background-color 0.3s;
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
    }
    .header-btn:hover {
      background: var(--accent);
      color: white;
    }

    #settingsButtonContainer {
        position: absolute;
        right: 16px; /* Adjust this value to your preference */
        top: 50%;
        transform: translateY(-50%);
    }
    #settingsIconBtn {
      background: var(--settings-icon-bg);
      border: none;
      font-size: 1.5em; /* Adjust as needed */
      cursor: pointer;
      color: var(--text);
      border-radius: 50%; /* Rounded */
      padding: 8px; /* Padding around the icon */
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px; /* Explicit width */
      height: 40px; /* Explicit height */
      transition: background-color 0.3s; /* Smooth transition for background */
    }
    #settingsIconBtn:hover {
      background: var(--accent);
      color: white;
    }

    .container { background:var(--card-bg); padding:25px; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.15); width:100%; max-width:500px; /* position:relative; no longer needed if settings btn is in header */ }
    /* input styles will be handled by #wordInputText and #wordInputTextarea directly */
    .result-box { background:var(--input-bg); padding:16px; border-radius:10px; font-family:'Courier New', monospace; white-space:pre-wrap; font-size:1em; color:var(--text); }
    /* .theme-btn removed */
    .modal { position:fixed; top:0; left:0; right:0; bottom:0; display:none; justify-content:center; align-items:center; background:rgba(0,0,0,0.5); z-index:100; }
    .modal-content { background:var(--card-bg); padding:20px; border-radius:12px; width:90%; max-width:400px; text-align:center; position:relative; max-height:80vh; overflow-y:auto; }
    .close-btn { position:absolute; top:10px; right:15px; background:none; border:none; font-size:1.2em; color:var(--text); cursor:pointer; }
    .theme-section { text-align:left; margin-top:15px; }
    .theme-section h3 { margin-bottom:10px; font-size:1em; border-bottom:1px solid var(--input-bg); padding-bottom:5px; }
    .theme-option { display:block; width:100%; padding:12px; margin:6px 0; border:none; border-radius:8px; font-size:1em; cursor:pointer; color:white; }

    /* Settings Modal & Layout Options */
    #settingsIconBtn { /* Already has inline styles, but can be enhanced here if needed */
      padding: 5px; /* Ensure it's not too large */
    }
    .settings-section h3, .modal-content > h3 { /* Target direct h3 under modal-content and specific section h3s */
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 1.15em; /* Unified font size */
      color: var(--text);
      border-bottom: 1px solid var(--input-bg);
      padding-bottom: 8px;
    }
    .theme-section h3 { /* Sub-headings for Light/Dark themes */
        font-size: 1.05em; /* Slightly smaller than main section titles */
        margin-top: 15px;
        margin-bottom: 8px;
        border-bottom-style: dashed; /* Differentiate sub-section borders */
    }
    .layout-option {
      cursor: pointer;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      background-color: var(--input-bg);
      color: var(--text);
      width: calc(50% - 10px); /* Two options side-by-side */
      transition: background-color 0.2s;
    }
    .layout-option:hover {
      background-color: var(--accent);
      color: white;
    }
    .layout-option.active-layout {
      background-color: var(--accent); /* Similar to hover, or a distinct color */
      color: white;
      border: 2px solid var(--bg); 
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .layout-option { /* Ensure the whole button is a flex column */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* Center content vertically if there's extra space */
      /* width, padding, etc. already defined and seem okay */
    }
    .layout-icon { /* Container for the SVG */
      margin-bottom: 5px; /* Space between icon and text */
      height: 35px;  /* Slightly increased icon visual height */
      width: auto;   /* Maintain aspect ratio based on height */
      display: flex; 
      align-items: center; 
      justify-content: center; 
    }
    .layout-icon svg {
      fill: currentColor; 
      height: 100%; /* SVG takes full height of .layout-icon */
      width: auto;  /* Maintain aspect ratio */
    }
    .theme-option.active-theme {
      border: 2px solid var(--text); 
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
      font-weight: bold;
    }


    /* Content Area Layouts */
    .content-area {
      display: flex;
      width: 100%;
    }

    /* Default: Side-by-Side Layout */
    .content-area {
      flex-direction: row;
      justify-content: space-between;
      gap: 20px; 
    }
    /* Styles for wordInputTextarea (Side-by-Side) */
    #wordInputTextarea {
      flex-basis: calc(50% - 10px); /* Restored flex-basis */
      padding: 12px;
      font-size: 1em;
      border: 1px solid var(--input-bg); /* Subtle border */
      border-radius: 8px;
      background: var(--input-bg);
      color: var(--text);
      margin-bottom: 0;
      resize: none; /* Disabled manual resize, will be dynamic */
      overflow-y: hidden; /* Hide scrollbar, height adjusts */
      min-height: 50px; /* Start with a decent min-height */
      white-space: pre-wrap; 
      word-wrap: break-word; 
      font-family: 'Didact Gothic', sans-serif; /* Ensure font consistency */
    }
     #wordInputTextarea::placeholder { color:#888; }

    .result-box {
      flex-basis: calc(50% - 10px);
      align-self: stretch; 
    }

    /* Original Layout Override Styles */
    body.layout-original .content-area {
      flex-direction: column;
      gap: 20px; 
    }
    /* Styles for wordInputText (Original) */
    body.layout-original #wordInputText {
      width: 100%; /* Restored width property */
      padding: 12px;
      font-size: 1em;
      border: 1px solid var(--input-bg); 
      border-radius: 8px;
      background: var(--input-bg);
      color: var(--text);
      margin-bottom: 10px; /* Restored margin-bottom */
      font-family: 'Didact Gothic', sans-serif; 
    }
    body.layout-original #wordInputText::placeholder { color:#888; }

    body.layout-original .result-box {
      flex-basis: auto; 
      width: 100%;
    }
    body.layout-original .content-area {
      flex-direction: column;
      gap: 10px; /* Restored gap property */
    }
    
    /* Hidden helper span for text width calculation - still needed for other potential uses or if we bring back dynamic width for something else */
    #text-width-helper {
      position: absolute;
      visibility: hidden;
      white-space: nowrap;
      font-family: 'Didact Gothic', sans-serif; 
      font-size: 1em; 
      padding: 0 12px; 
    }

    /* Button Colors */
    .light-btn { background:#0077cc; }
    .solarized-btn { background:#268bd2; }
    .cherry-btn { background:#cc0000; }
    .peach-btn { background:#ff7f50; }
    .sunshine-btn { background:#fbc02d; color:#000; }
    .forest-btn { background:#2e8b57; }
    .ocean-btn { background:#00acc1; }
    .azure-btn { background:#3399ff; }
    .bluelight-btn { background:#007bff; }
    .violetlight-btn { background:#7e57c2; }
    .plum-btn { background:#9c27b0; }
    .reddishpurple-btn { background:#ad1457; }
    .blush-btn { background:#f06292; }
    .rose-btn { background:#d81b60; }
    .brownlight-btn { background:#8d6e63; }
    .greyscale-btn { background:#888; }
    .dark-btn { background:#333; }
    .midnight-btn { background:#415a77; }
    .reddark-btn { background:#cc0000; }
    .orangedark-btn { background:#ff7f00; }
    .yellowdark-btn { background:#ffc107; }
    .greendark-btn { background:#2e7d32; }
    .cyandark-btn { background:#00acc1; }
    .azuredark-btn { background:#3399ff; }
    .deepsea-btn { background:#39cccc; }
    .violetnight-btn { background:#a18aff; }
    .purpledark-btn { background:#7e57c2; }
    .merlot-btn { background:#c2185b; }
    .lightpinkdark-btn { background:#f06292; }
    .hotpinkdark-btn { background:#d81b60; }
    .browndark-btn { background:#8d6e63; }
    .charcoal-btn { background:#444; }

    /* New Ash Theme Button Colors */
    /* .ashwood-btn and .slateash-btn removed */
    .ash-btn { background: #8892A0; color: white; } /* Accent of Ash (grey) */
    .infernoslate-btn { background: #A8DADC; color: #333a45; } /* Accent of Inferno Slate (teal), dark text */

    /* New Onyx Theme Button Colors */
    .obsidian-btn { background: #111111; color: white;} /* Dark BG, White text */
    .blackopal-btn { background: #111111; color: white;} /* Dark BG, White text */
    
    /* Camera Button and Modal Styles */
    .main-content-wrapper {
      width: 100%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Aligns children to the left */
    }
    .camera-btn-repositioned {
      background-color: var(--accent);
      color: white;
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      margin-top: 15px; /* Space below the main container */
    }
    .camera-btn-repositioned {
        display: none; /* Hiding the camera button as requested */
    }
    #saveCombinationBtn {
      background-color: var(--accent);
      color: white;
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      margin-top: 15px;
    }
    #saveCombinationBtn:hover {
      background-color: var(--text);
    }
    #saveCombinationBtn:active {
      transform: scale(0.98);
    }
    #cameraStatus {
      font-size: 1em;
      margin-bottom: 15px;
      min-height: 20px;
    }
    #captureBtn {
        background-color: var(--accent);
        color: white;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        cursor: pointer;
    }

    /* Save Combination Modal Styles */
    .palette {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 15px 0;
    }
    .palette-color {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid transparent;
        transition: transform 0.2s, border-color 0.2s;
    }
    .palette-color:hover {
        transform: scale(1.1);
    }
    .palette-color.active-color {
        border-color: var(--accent);
        transform: scale(1.15);
    }
    .palette-color.grey { background-color: #787c7e; }
    .palette-color.yellow { background-color: #c9b458; }
    .palette-color.green { background-color: #6aaa64; }
    
    .saved-item .wordle-box {
        background-color: #787c7e; /* Default grey for preview */
    }
    .saved-item .wordle-box[style*="yellow"] { background-color: #c9b458 !important; }
    .saved-item .wordle-box[style*="green"] { background-color: #6aaa64 !important; }
    .saved-item .wordle-box[style*="grey"] { background-color: #787c7e !important; }


    .wordle-grid {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    .wordle-row {
        display: flex;
        justify-content: center;
        gap: 10px;
    }
    .wordle-box {
        width: 50px;
        height: 50px;
        border: 2px solid #565758;
        background-color: #787c7e; /* Default to grey */
        color: white;
        font-size: 1.8em;
        font-weight: bold;
        text-align: center;
        text-transform: uppercase;
        caret-color: transparent; /* Hide cursor */
    }
    .test-word-input {
        width: 290px; /* 5 boxes * 50px + 4 gaps * 10px = 290px */
        margin-left: auto;
        margin-right: auto;
        display: block;
        padding: 12px;
        font-size: 1em;
        border: 1px solid var(--input-bg);
        border-radius: 8px;
        background: var(--input-bg);
        color: var(--text);
        margin-bottom: 20px;
    }
    .main-page-input {
        width: 100%;
        margin-top: 20px;
    }
    #searchInput {
        width: 100%;
        margin-bottom: 15px;
    }
    .save-data-btn {
        background-color: var(--accent);
        color: white;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        cursor: pointer;
    }

    /* Search Modal List Styles */
    #savedCombinationsList {
        display: flex;
        flex-direction: column;
        gap: 15px;
        max-height: 60vh; /* Make list scrollable if it gets too long */
        overflow-y: auto;
        padding-right: 10px; /* Space for scrollbar */
    }
    .saved-item {
        border: 1px solid var(--input-bg);
        border-radius: 8px;
        padding: 15px;
    }
    .saved-item .wordle-grid { /* Reuse wordle-grid styles for preview */
        transform: scale(0.7); /* Make preview smaller */
        transform-origin: top center;
        margin-bottom: -20px; /* Adjust layout due to scaling */
        pointer-events: none; /* Make preview unclickable */
        margin-left: auto;
        margin-right: auto;
    }
    .saved-item-info {
        margin-top: 10px;
    }
    .saved-item-info p {
        margin: 4px 0;
        font-size: 0.9em;
    }
    .saved-item-actions {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        justify-content: center;
    }
    .open-btn, .delete-btn {
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        color: white;
    }
    .open-btn { background-color: var(--accent); }
    .delete-btn { background-color: #e63946; } /* A consistent delete color */
  </style>
</head>
<body class="light">
  <div class="app-header">
    <button id="searchBtn" class="header-btn">🔍</button>
    <h2>Letter Frequency</h2>
    <div id="settingsButtonContainer" style="right:0;">
      <button id="settingsIconBtn" class="header-btn" onclick="openModal()">⚙️</button>
    </div>
  </div>
  <div class="main-content-wrapper">
    <input type="hidden" id="loadedCombinationId">
    <div class="container">
      <div class="content-area">
        <!-- Inputs will be shown/hidden based on layout -->
        <input type="text" id="wordInputText" placeholder="Type words here..." style="display:none;" oninput="handleWordInput()" />
        <textarea id="wordInputTextarea" placeholder="Type words here..." style="display:none;" oninput="handleWordInput()"></textarea>
        <div id="result" class="result-box"></div>
      </div>
      <input type="text" id="mainTestWordInput" placeholder="Enter test word here..." class="test-word-input main-page-input">
    </div>
    <button id="saveCombinationBtn">Save Combination</button>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal">
    <div class="modal-content">
      <button class="close-btn" onclick="closeModal('settingsModal')">✕</button>
      
      <div class="settings-section">
        <h3>Layout Options</h3>
        <div style="display: flex; justify-content: space-around; margin-bottom: 20px;">
          <div id="layout-side-by-side" class="layout-option" onclick="setLayout('side-by-side')">
            <div class="layout-icon">
              <svg viewBox="0 0 100 60"><rect x="10" y="5" width="35" height="50" rx="3"/><rect x="55" y="5" width="35" height="50" rx="3"/></svg>
            </div>
            <div>Side-by-Side</div>
          </div>
          <div id="layout-original" class="layout-option" onclick="setLayout('original')">
            <div class="layout-icon">
              <svg viewBox="0 0 100 60"><rect x="10" y="15" width="80" height="30" rx="3"/></svg>
            </div>
            <div>Original</div>
          </div>
        </div>
      </div>

      <h3>Select a Theme</h3>
      <div class="theme-section">
        <h3>Light Themes</h3>
        <button class="theme-option light-btn" onclick="setTheme('light')">Light</button>
        <button class="theme-option solarized-btn" onclick="setTheme('solarized')">Polarized</button>
        <button class="theme-option cherry-btn" onclick="setTheme('cherry')">Red Light</button>
        <button class="theme-option peach-btn" onclick="setTheme('peach')">Orange Light</button>
        <button class="theme-option sunshine-btn" onclick="setTheme('sunshine')">Yellow Light</button>
        <button class="theme-option forest-btn" onclick="setTheme('forest')">Green Light</button>
        <button class="theme-option ocean-btn" onclick="setTheme('ocean')">Cyan Light</button>
        <button class="theme-option azure-btn" onclick="setTheme('azure')">Cornflower Blue Light</button>
        <button class="theme-option bluelight-btn" onclick="setTheme('bluelight')">Normal Blue Light</button>
        <button class="theme-option violetlight-btn" onclick="setTheme('violetlight')">Bluish Purple Light</button>
        <button class="theme-option plum-btn" onclick="setTheme('plum')">Normal Purple Light</button>
        <button class="theme-option reddishpurple-btn" onclick="setTheme('reddishpurple')">Reddish Purple Light</button>
        <button class="theme-option blush-btn" onclick="setTheme('blush')">Light Pink Light</button>
        <button class="theme-option rose-btn" onclick="setTheme('rose')">Hot Pink Light</button>
        <button class="theme-option brownlight-btn" onclick="setTheme('brownlight')">Brown Light</button>
        <button class="theme-option greyscale-btn" onclick="setTheme('greyscale')">Grey Light</button>
      </div>
      <div class="theme-section">
        <h3>Ash Themes</h3>
        <button class="theme-option ash-btn" onclick="setTheme('ash')">Ash</button>
      </div>
      <div class="theme-section">
        <h3>Dark Themes</h3>
        <button class="theme-option dark-btn" onclick="setTheme('dark')">Dark</button>
        <button class="theme-option midnight-btn" onclick="setTheme('midnight')">Midnight</button>
        <button class="theme-option reddark-btn" onclick="setTheme('reddark')">Red Dark</button>
        <button class="theme-option orangedark-btn" onclick="setTheme('orangedark')">Orange Dark</button>
        <button class="theme-option yellowdark-btn" onclick="setTheme('yellowdark')">Yellow Dark</button>
        <button class="theme-option greendark-btn" onclick="setTheme('greendark')">Green Dark</button>
        <button class="theme-option cyandark-btn" onclick="setTheme('cyandark')">Cyan Dark</button>
        <button class="theme-option azuredark-btn" onclick="setTheme('azuredark')">Cornflower Blue Dark</button>
        <button class="theme-option deepsea-btn" onclick="setTheme('deepsea')">Normal Blue Dark</button>
        <button class="theme-option violetnight-btn" onclick="setTheme('violetnight')">Bluish Purple Dark</button>
        <button class="theme-option purpledark-btn" onclick="setTheme('purpledark')">Normal Purple Dark</button>
        <button class="theme-option merlot-btn" onclick="setTheme('merlot')">Reddish Purple Dark</button>
        <button class="theme-option lightpinkdark-btn" onclick="setTheme('lightpinkdark')">Light Pink Dark</button>
        <button class="theme-option hotpinkdark-btn" onclick="setTheme('hotpinkdark')">Hot Pink Dark</button>
        <button class="theme-option browndark-btn" onclick="setTheme('browndark')">Brown Dark</button>
        <button class="theme-option charcoal-btn" onclick="setTheme('charcoal')">Grey Dark</button>
        <button class="theme-option infernoslate-btn" onclick="setTheme('infernoslate')">Inferno Slate</button>
      </div>
      <div class="theme-section">
        <h3>Onyx Themes</h3>
        <button class="theme-option obsidian-btn" onclick="setTheme('obsidian')">Obsidian</button>
        <button class="theme-option blackopal-btn" onclick="setTheme('blackopal')">Black Opal</button>
      </div>
    </div>
  </div>
  <script>
    // Helper span for dynamic input width calculation
    let textWidthHelper; 

    function setupTextWidthHelperFont() {
        if (textWidthHelper && activeInputElement) {
            const style = window.getComputedStyle(activeInputElement);
            textWidthHelper.style.fontFamily = style.fontFamily;
            textWidthHelper.style.fontSize = style.fontSize;
            textWidthHelper.style.paddingLeft = style.paddingLeft; // Use the actual padding of the input
            textWidthHelper.style.paddingRight = style.paddingRight;
        }
    }

    function updateInputWidth(inputElement) {
      // This function is no longer used for dynamic width expansion of wordInputText.
      // It was for the previous behavior. Keeping it here for now in case
      // any other input might need it in the future, or it can be removed later.
      // console.log("updateInputWidth called, but is deprecated for wordInputText");
    }

    function updateTextareaHeight(textareaElement) {
      textareaElement.style.height = 'auto'; // Temporarily shrink to get correct scrollHeight
      // Increased max-height: 500px fixed, or 60% of viewport height
      const maxHeight = Math.min(500, window.innerHeight * 0.6); 
      
      // Only apply scrollHeight if it's different and less than maxHeight, or if it's beyond maxHeight
      const newHeight = textareaElement.scrollHeight;

      if (newHeight > maxHeight) {
        textareaElement.style.height = maxHeight + 'px';
        textareaElement.style.overflowY = 'auto'; // Show scrollbar if content exceeds max-height
      } else {
        textareaElement.style.height = newHeight + 'px';
        textareaElement.style.overflowY = 'hidden'; // Hide scrollbar if content is within bounds
      }
    }

    let activeInputElement; // To store the currently active input

    function handleWordInput() {
        if (activeInputElement) {
            if (activeInputElement.id === 'wordInputText') {
                // No longer calling updateInputWidth for wordInputText
            } else if (activeInputElement.id === 'wordInputTextarea') {
                updateTextareaHeight(activeInputElement);
            }
        }
        countLetters();
    }

    function countLetters() {
      if (!activeInputElement) return; // Do nothing if no input is active
      const inputValue = activeInputElement.value.toLowerCase();
      const words = inputValue.match(/\b\w+\b/g) || [];
      const letterMap = {};
      words.forEach(word => {
        const uniqueLetters = new Set(word.replace(/[^a-z]/g, ''));
        uniqueLetters.forEach(letter => {
          letterMap[letter] = (letterMap[letter] || 0) + 1;
        });
      });
      const sorted = Object.entries(letterMap).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
      const output = sorted.map(([letter, count]) => `${letter}: ${count}`).join('\n');
      document.getElementById('result').textContent = output || 'No letters found.';
    }
    function setTheme(theme) {
      // Preserve layout class when changing theme
      const currentLayoutClass = document.body.classList.contains('layout-original') ? 'layout-original' : '';
      document.body.className = theme; // This overwrites all classes
      if (currentLayoutClass) {
        document.body.classList.add(currentLayoutClass);
      }
      localStorage.setItem('selectedTheme', theme);
      updateActiveThemeButton(theme);
      closeModal('settingsModal'); // Close settings modal after theme selection
    }

    function updateActiveThemeButton(activeTheme) {
      document.querySelectorAll('.theme-option').forEach(btn => {
        if (btn.textContent.toLowerCase() === activeTheme.replace(/-/g, ' ').toLowerCase() || 
            btn.onclick.toString().includes(`setTheme('${activeTheme}')`)) {
          btn.classList.add('active-theme');
        } else {
          btn.classList.remove('active-theme');
        }
      });
    }
    
    function updateActiveLayoutButton(activeLayout) {
        document.querySelectorAll('.layout-option').forEach(btn => btn.classList.remove('active-layout'));
        const activeBtn = document.getElementById(`layout-${activeLayout}`);
        if (activeBtn) {
            activeBtn.classList.add('active-layout');
        }
    }

    function applyLayout(layoutName) {
      const wordInputText = document.getElementById('wordInputText');
      const wordInputTextarea = document.getElementById('wordInputTextarea');

      if (layoutName === 'original') {
        document.body.classList.add('layout-original');
        wordInputText.style.display = 'block'; 
        wordInputTextarea.style.display = 'none';
        activeInputElement = wordInputText;
        // No longer calling updateInputWidth here for wordInputText
        wordInputText.style.width = '100%'; // Ensure it's full width on layout switch
      } else { // 'side-by-side' or default
        document.body.classList.remove('layout-original');
        wordInputText.style.display = 'none';
        wordInputTextarea.style.display = 'block';
        activeInputElement = wordInputTextarea;
        updateTextareaHeight(activeInputElement); // Set initial height for textarea
      }
      // Transfer value between inputs if necessary, or clear the hidden one
      const visibleInput = (layoutName === 'original') ? wordInputText : wordInputTextarea;
      const hiddenInput = (layoutName === 'original') ? wordInputTextarea : wordInputText;
      // visibleInput.value = hiddenInput.value; // Option 1: transfer value
      // hiddenInput.value = ''; // Option 2: clear hidden (let's go with this to avoid confusion)
      // Let's try to keep the value if the user switches back and forth for a better UX
      if (document.activeElement !== visibleInput) { // Avoid clearing if user is typing and layout switches programmatically
          // No, this is complex. Let's just ensure the current activeInput has the value.
          // When switching, the value of the *newly visible* input should be what matters.
          // If they were sharing a value, it's simpler. Let's assume they should share value.
      }
      // If values are not shared, ensure countLetters runs on the new activeInputElement's value
      countLetters(); 


      updateActiveLayoutButton(layoutName);
    }

    function setLayout(layoutName) {
      const oldActiveValue = activeInputElement ? activeInputElement.value : "";
      applyLayout(layoutName); // This now sets the new activeInputElement
      if (activeInputElement) { // The new active input
        activeInputElement.value = oldActiveValue; // Preserve text across layout changes
        // Trigger the appropriate resize function for the now visible and value-filled input
        if (activeInputElement.id === 'wordInputText') {
          updateInputWidth(activeInputElement);
        } else if (activeInputElement.id === 'wordInputTextarea') {
          updateTextareaHeight(activeInputElement);
        }
      }
      localStorage.setItem('selectedLayout', layoutName);
      closeModal('settingsModal'); // Close modal after layout selection
    }

    function openModal() {
      document.getElementById('settingsModal').style.display = 'flex';
      // Refresh active buttons when modal opens
      const savedTheme = localStorage.getItem('selectedTheme') || 'light';
      const savedLayout = localStorage.getItem('selectedLayout') || 'side-by-side';
      updateActiveThemeButton(savedTheme);
      updateActiveLayoutButton(savedLayout);
      // Add event listener for outside click when modal opens
      document.getElementById('settingsModal').addEventListener('click', handleModalOutsideClick);
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
            modal.removeEventListener('click', handleModalOutsideClick);
        }
    }

    function handleModalOutsideClick(event) {
        if (event.target.classList.contains('modal')) {
            closeModal(event.target.id);
        }
    }

    function initializePage() {
      const wordInputText = document.getElementById('wordInputText');
      const wordInputTextarea = document.getElementById('wordInputTextarea');

      const savedTheme = localStorage.getItem('selectedTheme') || 'light';
      const savedLayout = localStorage.getItem('selectedLayout') || 'side-by-side';
      
      document.body.className = savedTheme; 
      // Determine which input to show initially based on savedLayout
      if (savedLayout === 'original') {
        wordInputText.style.display = 'block';
        wordInputTextarea.style.display = 'none';
        activeInputElement = wordInputText;
      } else {
        wordInputText.style.display = 'none';
        wordInputTextarea.style.display = 'block';
        activeInputElement = wordInputTextarea;
      }
      
      applyLayout(savedLayout); // This will also call updateActiveLayoutButton and initial resize
      
      updateActiveThemeButton(savedTheme);

      // Ensure initial state of inputs is good if there's no saved text.
      // If there was saved text, setLayout would have handled it.
      // This mainly ensures the initial placeholder resize is correct.
      // Also, setup the font for the helper span based on the initially active input.
      setupTextWidthHelperFont(); // Still useful if textWidthHelper is used for anything else
      if (activeInputElement.id === 'wordInputText') {
          // No initial width update needed for wordInputText as it's 100% CSS driven now
          activeInputElement.style.width = '100%'; // Ensure it is 100% on init
      } else if (activeInputElement.id === 'wordInputTextarea') {
          updateTextareaHeight(activeInputElement);
      }

      countLetters(); // Initial calculation
    }

    // DOMContentLoaded ensures that elements are available before JS tries to manipulate them
    document.addEventListener('DOMContentLoaded', () => {
        // Create the helper span once DOM is loaded
        textWidthHelper = document.createElement('span');
        textWidthHelper.id = 'text-width-helper'; // ID for potential CSS styling if needed
        textWidthHelper.style.position = 'absolute';
        textWidthHelper.style.visibility = 'hidden';
        textWidthHelper.style.whiteSpace = 'nowrap';
        // Font family, size, and padding will be set by setupTextWidthHelperFont() 
        // based on the active input, so no need to set them here initially.
        document.body.appendChild(textWidthHelper);
        
        // Add event listener for camera button - REMOVED
        // document.getElementById('cameraBtn').addEventListener('click', openCamera); - REMOVED
        // document.getElementById('captureBtn').addEventListener('click', recognizeTextFromVideo); - REMOVED
        
        // initializeWordSet(); // Initialize the dictionary Set - REMOVED
        
        // Save Combination Modal Listeners
        document.getElementById('saveCombinationBtn').addEventListener('click', openSaveModal);
        document.querySelector('#saveCombinationModal .palette').addEventListener('click', selectPaletteColor);
        document.querySelector('#saveCombinationModal .wordle-grid').addEventListener('click', colorWordleBox);
        document.querySelector('#saveCombinationModal .wordle-grid').addEventListener('keydown', handleWordleBoxKeyDown);
        document.getElementById('saveCombinationDataBtn').addEventListener('click', saveCombinationData);
        document.getElementById('saveCombinationModal').addEventListener('click', handleModalOutsideClick);

        // Search Modal Listeners
        document.getElementById('searchBtn').addEventListener('click', openSearchModal);
        document.getElementById('savedCombinationsList').addEventListener('click', handleSavedListClick);
        document.getElementById('searchModal').addEventListener('click', handleModalOutsideClick);
        
        initializePage(); // Initialize after helper span is created
    });

    let selectedColor = 'grey'; // Default selected color

    function openSaveModal() {
        const loadedId = document.getElementById('loadedCombinationId').value;
        if (loadedId) {
            // If an ID is loaded, populate the modal with its data
            const combinations = JSON.parse(localStorage.getItem('savedCombinations')) || [];
            const comboToLoad = combinations.find(c => c.id.toString() === loadedId);
            if (comboToLoad) {
                loadCombinationIntoSaveModal(comboToLoad);
            }
        } else {
            // Otherwise, clear the modal for a new entry and pre-fill the test word
            clearSaveModal();
            document.getElementById('testWordInput').value = document.getElementById('mainTestWordInput').value;
        }
        document.getElementById('saveCombinationModal').style.display = 'flex';
    }

    function closeSaveModal() {
        document.getElementById('saveCombinationModal').style.display = 'none';
        clearSaveModal(); // Always clear modal on close
    }

    function clearSaveModal() {
        document.querySelectorAll('#saveCombinationModal .wordle-box').forEach(box => {
            box.value = '';
            box.style.backgroundColor = '#787c7e';
            box.dataset.color = 'grey';
        });
        document.getElementById('testWordInput').value = '';
        document.getElementById('combinationId').value = '';
    }

    function selectPaletteColor(event) {
        const target = event.target;
        if (!target.classList.contains('palette-color')) return;

        // Update selected color variable
        selectedColor = target.dataset.color;
        
        // Update active class
        document.querySelectorAll('.palette-color').forEach(c => c.classList.remove('active-color'));
        target.classList.add('active-color');
    }

    function colorWordleBox(event) {
        const target = event.target;
        if (!target.classList.contains('wordle-box')) return;
        
        const colorMap = {
            grey: '#787c7e',
            yellow: '#c9b458',
            green: '#6aaa64'
        };

        target.style.backgroundColor = colorMap[selectedColor];
        target.dataset.color = selectedColor; // Store color on the element
    }

    function handleWordleBoxKeyDown(event) {
        const target = event.target;
        const key = event.key;

        // On Backspace, if the current box is empty, move to the previous box
        if (key === 'Backspace' && target.value === '' && target.previousElementSibling) {
            target.previousElementSibling.focus();
        }
        
        // On letter/number input, replace content and move to the next box
        if (/^[a-zA-Z0-9]$/.test(key)) {
            target.value = ''; // Clear the box before setting new value to handle replacement
            setTimeout(() => { // Use a timeout to ensure the value is set before moving focus
                if (target.value && target.nextElementSibling) {
                    target.nextElementSibling.focus();
                }
            }, 0);
        }
    }

    function openSearchModal() {
        renderCombinations(); // Initial render
        const searchModal = document.getElementById('searchModal');
        const searchGrid = searchModal.querySelector('.wordle-grid');
        searchGrid.addEventListener('input', renderCombinations);
        searchGrid.addEventListener('click', renderCombinations); // For color changes
        searchModal.style.display = 'flex';
        searchModal.addEventListener('click', handleModalOutsideClick);
    }

    function renderCombinations() {
        const listContainer = document.getElementById('savedCombinationsList');
        const combinations = JSON.parse(localStorage.getItem('savedCombinations')) || [];
        
        // Get search criteria from the search modal's grid
        const searchRows = document.querySelectorAll('#searchModal .wordle-row');
        const searchCriteria = [];
        searchRows.forEach(row => {
            const rowCriteria = [];
            row.querySelectorAll('.wordle-box').forEach(box => {
                rowCriteria.push({
                    letter: box.value.toUpperCase(),
                    color: box.dataset.color || 'grey'
                });
            });
            searchCriteria.push(rowCriteria);
        });

        const filteredCombinations = combinations.filter(combo => {
            // Match every search box condition with the corresponding box in the saved combination
            return searchCriteria.every((searchRow, rowIndex) => {
                return searchRow.every((searchBox, boxIndex) => {
                    const savedBox = combo.rows[rowIndex][boxIndex];
                    const letterMatch = !searchBox.letter || (savedBox.letter === searchBox.letter);
                    const colorMatch = savedBox.color === searchBox.color;
                    return letterMatch && colorMatch;
                });
            });
        });

        if (filteredCombinations.length === 0) {
            listContainer.innerHTML = '<p>No matching combinations found.</p>';
        } else {
            listContainer.innerHTML = filteredCombinations.map(combo => {
                const date = new Date(combo.id).toLocaleString();
                const gridHtml = combo.rows.map(row => `
                    <div class="wordle-row">
                        ${row.map(box => `<div class="wordle-box" style="background-color:${box.color};">${box.letter}</div>`).join('')}
                    </div>
                `).join('');

                return `
                    <div class="saved-item">
                        <div class="wordle-grid">${gridHtml}</div>
                        <div class="saved-item-info">
                            <p><strong>Test Word:</strong> ${combo.testWord || 'None'}</p>
                            <p><strong>Saved on:</strong> ${date}</p>
                        </div>
                        <div class="saved-item-actions">
                            <button class="open-btn" data-id="${combo.id}">Open</button>
                            <button class="delete-btn" data-id="${combo.id}">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }

    function closeSearchModal() {
        const searchModal = document.getElementById('searchModal');
        const searchGrid = searchModal.querySelector('.wordle-grid');
        // Remove listeners to prevent multiple bindings if modal is reopened
        searchGrid.removeEventListener('input', renderCombinations);
        searchGrid.removeEventListener('click', renderCombinations);
        closeModal('searchModal');
    }

    function handleSavedListClick(event) {
        const target = event.target;
        const comboId = target.dataset.id;

        if (!comboId) return;

        if (target.classList.contains('delete-btn')) {
            deleteCombination(comboId);
        } else if (target.classList.contains('open-btn')) {
            loadCombinationToMainPage(comboId);
        }
    }

    function loadCombinationToMainPage(id) {
        const combinations = JSON.parse(localStorage.getItem('savedCombinations')) || [];
        const comboToLoad = combinations.find(c => c.id.toString() === id.toString());

        if (!comboToLoad) {
            alert('Error: Could not find combination to load.');
            return;
        }
        
        // Populate main page inputs
        const words = comboToLoad.rows.map(row => row.map(box => box.letter).join('')).join('\n');
        if (activeInputElement) {
            activeInputElement.value = words;
            handleWordInput(); // Trigger count and resize
            if (activeInputElement.id === 'wordInputTextarea') {
                updateTextareaHeight(activeInputElement);
            }
        }
        document.getElementById('mainTestWordInput').value = comboToLoad.testWord;
        
        // Track the loaded combination ID on the main page
        document.getElementById('loadedCombinationId').value = comboToLoad.id;

        closeSearchModal();
    }

    function loadCombinationIntoSaveModal(comboData) {
        // This function populates the save modal, it doesn't open it
        const rows = document.querySelectorAll('#saveCombinationModal .wordle-row');
        const colorMap = { grey: '#787c7e', yellow: '#c9b458', green: '#6aaa64' };

        rows.forEach((row, rowIndex) => {
            const boxes = row.querySelectorAll('.wordle-box');
            boxes.forEach((box, boxIndex) => {
                const data = comboData.rows[rowIndex][boxIndex];
                box.value = data.letter;
                box.dataset.color = data.color;
                box.style.backgroundColor = colorMap[data.color];
            });
        });

        document.getElementById('testWordInput').value = comboData.testWord;
        document.getElementById('combinationId').value = comboData.id;
    }

    function deleteCombination(id) {
        if (confirm('Are you sure you want to delete this combination?')) {
            let combinations = JSON.parse(localStorage.getItem('savedCombinations')) || [];
            combinations = combinations.filter(combo => combo.id.toString() !== id.toString());
            localStorage.setItem('savedCombinations', JSON.stringify(combinations));
            renderCombinations(); // Refresh the list after deletion
        }
    }

    function saveCombinationData() {
        const combinationIdInput = document.getElementById('combinationId');
        const existingId = combinationIdInput.value;

        const rows = document.querySelectorAll('#saveCombinationModal .wordle-row');
        const rowsData = [];

        rows.forEach(row => {
            const rowData = [];
            const boxes = row.querySelectorAll('.wordle-box');
            boxes.forEach(box => {
                rowData.push({
                    letter: box.value.toUpperCase() || '',
                    color: box.dataset.color || 'grey'
                });
            });
            rowsData.push(rowData);
        });

        const testWord = document.getElementById('testWordInput').value;
        let combinations = JSON.parse(localStorage.getItem('savedCombinations')) || [];

        if (existingId) { // Update existing combination
            const comboIndex = combinations.findIndex(c => c.id.toString() === existingId);
            if (comboIndex > -1) {
                combinations[comboIndex].rows = rowsData; // Update with the new grid data from the modal
                combinations[comboIndex].testWord = testWord;
                // Optionally update a 'lastSaved' timestamp here if added to the object
                alert('Combination updated successfully!');
            } else {
                alert('Error: Could not find combination to update.');
                return; // Exit if a bad ID was found
            }
        } else { // Create new combination
            const newCombination = {
                id: Date.now(),
                rows: rowsData,
                testWord: testWord
            };
            combinations.push(newCombination);
            alert('Combination saved successfully!');
        }

        localStorage.setItem('savedCombinations', JSON.stringify(combinations));
        
        // Clear the hidden ID input and close modal
        combinationIdInput.value = '';
        closeSaveModal();
    }

    // All camera and OCR related functions and variables below are removed.
    // let videoStream = null; 
    // async function openCamera() { ... }
    // function closeCamera() { ... }
    // async function recognizeTextFromVideo() { ... }
    // let wordSet; 
    // function initializeWordSet() { ... }
    // function filterRealWords(text) { ... }

    let videoStream = null;
    let wordSet;

    document.addEventListener('DOMContentLoaded', () => {
        textWidthHelper = document.createElement('span');
        textWidthHelper.id = 'text-width-helper';
        textWidthHelper.style.position = 'absolute';
        textWidthHelper.style.visibility = 'hidden';
        textWidthHelper.style.whiteSpace = 'nowrap';
        document.body.appendChild(textWidthHelper);
        
        document.getElementById('cameraBtn').addEventListener('click', openCamera);
        document.getElementById('captureBtn').addEventListener('click', recognizeTextFromVideo);
        
        initializeWordSet();
        initializePage();
    });

    function initializeWordSet() {
        if (typeof wordList !== 'undefined' && wordList.length > 0) {
            wordSet = new Set(wordList.map(word => word.toLowerCase()));
            console.log(`Dictionary loaded with ${wordSet.size} words.`);
        } else {
            console.error("Word list not found or empty. OCR filtering will be basic.");
            wordSet = new Set();
        }
    }

    async function openCamera() {
      const cameraModal = document.getElementById('cameraModal');
      const video = document.getElementById('videoFeed');
      const status = document.getElementById('cameraStatus');
      const captureBtn = document.getElementById('captureBtn');

      cameraModal.style.display = 'flex';
      status.textContent = 'Requesting camera access...';
      captureBtn.style.display = 'none';
      video.style.display = 'none';

      try {
        videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        video.srcObject = videoStream;
        video.onloadedmetadata = () => {
          video.play();
          video.style.display = 'block';
          captureBtn.style.display = 'inline-block';
          status.textContent = 'Point camera at handwritten text and capture.';
        };
      } catch (err) {
        console.error("Camera Error:", err);
        status.textContent = 'Could not access camera. Please check permissions.';
        setTimeout(closeCamera, 3000);
      }
    }

    function closeCamera() {
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
      }
      videoStream = null;
      document.getElementById('cameraModal').style.display = 'none';
    }

    async function recognizeTextFromVideo() {
      const video = document.getElementById('videoFeed');
      const canvas = document.getElementById('captureCanvas');
      const context = canvas.getContext('2d');
      const status = document.getElementById('cameraStatus');

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      status.textContent = 'Loading Handwriting Recognition Model...';
      document.getElementById('captureBtn').style.display = 'none';

      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
          logger: m => {
            console.log(m);
            if (m.status === 'recognizing text') {
              status.textContent = `Recognizing... ${Math.round(m.progress * 100)}%`;
            } else if (m.status === 'loading language model') {
              status.textContent = `Loading Model: ${Math.round(m.progress * 100)}% (this may take a moment on first use)`;
            }
          }
        });
        
        const filteredText = filterRealWords(text);
        if (filteredText) {
          activeInputElement.value += (activeInputElement.value ? ' ' : '') + filteredText;
          handleWordInput();
          status.textContent = `Appended recognized words!`;
        } else {
          status.textContent = 'No valid words recognized. Please try again.';
        }
      } catch (err) {
        console.error(err);
        status.textContent = 'Could not recognize text. Please try again.';
      } finally {
        setTimeout(closeCamera, 2000);
      }
    }

    function filterRealWords(text) {
      if (!wordSet || wordSet.size === 0) {
        return text.replace(/[^a-zA-Z\s'-]/g, "").replace(/(\r\n|\n|\r)/gm, " ").trim();
      }
      const words = text.split(/\s+/);
      const realWords = [];
      for (const word of words) {
        const cleanedWord = word.toLowerCase().replace(/[^a-z'-]|(^['-])|(['-]$)/g, "");
        if (cleanedWord && wordSet.has(cleanedWord)) {
          realWords.push(cleanedWord);
        }
      }
      return realWords.join(" ").trim();
    }
  </script>

  <!-- Camera Modal -->
  <div class="modal" id="cameraModal">
    <div class="modal-content">
      <button class="close-btn" onclick="closeCamera()">✕</button>
      <p id="cameraStatus">Getting camera ready...</p>
      <video id="videoFeed" playsinline style="width:100%; height:auto; display:none;"></video>
      <canvas id="captureCanvas" style="display:none;"></canvas>
      <div style="text-align: center; margin-top: 15px;">
        <button id="captureBtn" style="display:none;">Capture Text</button>
      </div>
    </div>
  </div>

  <!-- Save Combination Modal -->
  <div class="modal" id="saveCombinationModal">
    <div class="modal-content">
        <button class="close-btn" onclick="closeSaveModal()">✕</button>
        <input type="hidden" id="combinationId">
        <h3>Save Wordle Combination</h3>
        
        <div class="palette">
            <div class="palette-color grey active-color" data-color="grey"></div>
            <div class="palette-color yellow" data-color="yellow"></div>
            <div class="palette-color green" data-color="green"></div>
        </div>

        <div class="wordle-grid">
            <div class="wordle-row">
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
            </div>
            <div class="wordle-row">
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
                <input type="text" maxlength="1" class="wordle-box" />
            </div>
        </div>

        <input type="text" id="testWordInput" placeholder="Your test word..." class="test-word-input">
        
        <button id="saveCombinationDataBtn" class="save-data-btn">Save Combination</button>
    </div>
  </div>

  <!-- Search Modal -->
  <div class="modal" id="searchModal">
      <div class="modal-content">
          <button class="close-btn" onclick="closeModal('searchModal')">✕</button>
          <h3>Search Combinations</h3>
          
          <div class="palette">
              <div class="palette-color grey active-color" data-color="grey"></div>
              <div class="palette-color yellow" data-color="yellow"></div>
              <div class="palette-color green" data-color="green"></div>
          </div>

          <div class="wordle-grid">
              <div class="wordle-row">
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
              </div>
              <div class="wordle-row">
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
                  <input type="text" maxlength="1" class="wordle-box" />
              </div>
          </div>

          <div id="savedCombinationsList">
              <!-- Saved items will be dynamically injected here -->
          </div>
      </div>
  </div>

</body>
</html>
